Joel on Software

>#Biculturalism

#两种文化

>######by Joel Spolsky Sunday, December 14, 2003

---


>By now, Windows and Unix are functionally more similar than different. They both support the same major programming metaphors, from command lines to GUIs to web servers; they are organized around virtually the same panoply of system resources, from nearly identical file systems to memory to sockets and processes and threads. There's not much about the core set of services provided by each operating system to limit the kinds of applications you can create.


到目前为止，Windows和Unix在功能上与其说不同不如说更多的是相似。 他们都支持同样的主流编程范式， 从命令行到用户界面到网络服务器；他们面对几乎都是同样豪华的系统资源，从几乎完全相同的文件系统到内存到网络套接字到进程和线程。几乎没有哪个操作系统提供的核心服务会阻止你来构建特定的应用程序


>What's left is cultural differences. Yes, we all eat food, but over there, they eat raw fish with rice using wood sticks, while over here, we eat slabs of ground cow on bread with our hands. A cultural difference doesn't mean that American stomachs can't digest sushi or that Japanese stomachs can't digest Big Macs, and it doesn't mean that there aren't lots of Americans who eat sushi or Japanese who eat burgers, but it does mean that Americans getting off the plane for the first time in Tokyo are confronted with an overwhelming feeling that this place is strange, dammit, and no amount of philosophizing about how underneath we're all the same, we all love and work and sing and die will overcome the fact that Americans and Japanese can neverreally get comfortable with each others' toilet arrangements.


>What are the cultural differences between Unix and Windows programmers? There are many details and subtleties, but for the most part it comes down to one thing: Unix culture values code which is useful to other programmers, while Windows culture values code which is useful to non-programmers.


剩下的就是文化差异。 是的，虽然我们都吃东西， 但是世界的那边，他们用筷子夹米饭包着的生鱼片吃；而这边，我们用手拿面包配牛排吃。 文化的差异并不是说美国人的胃就消化不了寿司或者日本人的胃就吃不了巨无霸汉堡， 也不能说明没有很多日本人吃汉堡或者是没有很多美国人吃寿司， 但是文化差异确实意味着美国人第一次在东京下飞机的后被一种感觉包围着：靠，这地方真是奇怪。毋庸多说哲学上我们的内在是何其的相似，我们都会相爱，都会工作，都会唱歌，都会终老死去， 这些就足以让大家互相克服一些困难，比如人们常说：美国人和日本人永远不可能适应对方厕所的布置。 那么Unix和Windows程序员的文化差异在哪儿呢？ 有很多的细节和微妙的地方， 但是最主要的一点： Unix文化看重代码的有用性对于其他程序员的价值， 而Windows文化则看重代码的有用性对于其他非程序员的价值。


>This is, of course, a major simplification, but really, that's the big difference: are we programming for programmers or end users? Everything else is commentary.


这样说当然是很大的简化， 但是说真的这就是最大的差别：我们是面向程序员还是面向终端用户编程？其他的都相对次要。


>The frequently controversial Eric S. Raymond has just written a long book about Unix programming called The Art of UNIX Programming exploring his own culture in great detail. You can buy the book and read it on paper, or, if Raymond's politics are just too anti-idiotarian for you to consider giving him money, you can even read itonline for free and rest assured that the author will not receive a penny for his hard work.


颇具争议性的Eric.S.Raymond刚刚写了一本关于Unix编程的冗长的书叫做《Unix编程艺术》巨细无遗的讨论了他自己的文化。 你可以到这里购买这本书在纸上阅读， 或者说如果Raymond的策略是太过于反对程序傻瓜化，以至于你不想给他钱花， 你甚至可以通过这里在网上免费阅读， 然后舒服地安慰自己作者不会因为这份努力得到一分钱。


>Let's look at a small example. The Unix programming culture holds in high esteem programs which can be called from the command line, which take arguments that control every aspect of their behavior, and the output of which can be captured as regularly-formatted, machine readable plain text. Such programs are valued because they can easily be incorporated into other programs or larger software systems by programmers. To take one miniscule example, there is a core value in the Unix culture, which Raymond calls "Silence is Golden," that a program that has done exactly what you told it to do successfully should provide no output whatsoever. It doesn't matter if you've just typed a 300 character command line to create a file system, or built and installed a complicated piece of software, or sent a manned rocket to the moon. If it succeeds, the accepted thing to do is simply output nothing. The user will infer from the next command prompt that everything must be OK.


我们来看一些小例子。 Unix程序的文化对程序能够从命令行运行深以为荣， 这些程序可以接受命令行参数来控制程序行为的方方面面，而程序的输出则可以以普通可读文本输出。 这样的程序很受器重因为它们很容易就能被其他程序员整合进其他程序或软件里。 举个微乎其微的例子， Unix文化里有个核心文化叫做“沉默是金”，具体就是说如果一个程序已经成功完成所有你让它做的事情那么它就不应该提供什么输出。不管你不是录入了300个字符创建一个文件系统 或者是编译安装了一个复杂的软件， 或者是把人造火箭送上了月球。 如果成功了，规矩就是什么都不输出。 用户可以从下一个命令提示符推测出一切正常。 


>This is an important value in Unix culture because you're programming for other programmers. As Raymond puts it, "Programs that babble don't tend to play well with other programs." By contrast, in the Windows culture, you're programming for Aunt Marge, and Aunt Marge might be justified in observing that a program that produces no output because it succeeded cannot be distinguished from a program that produced no output because it failed badly or a program that produced no output because it misinterpreted your request.


这在Unix文化里是非常重要的价值，正如Raymond所说，“那些喜欢罗里吧嗦的程序通常和其他程序合不来” 相比之下，在Window文化里，你帮Marge阿姨编程，那么Marge阿姨会认为程序运行成功不返回结果和程序理解错你的请求无法返回请求而出错是一样的，无法分辨。


>Similarly, the Unix culture appreciates programs that stay textual. They don't like GUIs much, except as lipstick painted cleanly on top of textual programs, and they don't like binary file formats. This is because a textual interface is easier to program against than, say, a GUI interface, which is almost impossible to program against unless some other provisions are made, like a built-in scripting language. Here again, we see that the Unix culture values creating code that is useful to other programmers, something which is rarely a goal in Windows programming.


类似的，Unix文化更喜欢程序保持文本化，除了清楚的叠在文本程序表面之外的亮彩色外，他们不太喜欢用户界面，他们也不喜欢二进制格式。 这是因为文本的接口要比例如说用户界面接口更容易编程。对于用户界面而言，除非制定一些特定的规则（例如内建一个脚本语言）外几乎无法二次开发。 这再一次让我们见识了Unix文化重视创建对其他程序员有用的代码， 而这根本不是Windows编程追求的目标。


>Which is not to say that all Unix programs are designed solely for programmers. Far from it. But the culture values things that are useful to programmers, and this explains a thing or two about a thing or two.


这也不是说所有的Unix程序都是为程序员设计的。 远非如此。 但是Unix文化重视对其他程序员有用的价值， 这也解释了一些现象的一些原因。

>Suppose you take a Unix programmer and a Windows programmer and give them each the task of creating the same end-user application. The Unix programmer will create a command-line or text-driven core and occasionally, as an afterthought, build a GUI which drives that core. This way the main operations of the application will be available to other programmers who can invoke the program on the command line and read the results as text. The Windows programmer will tend to start with a GUI, and occasionally, as an afterthought, add a scripting language which can automate the operation of the GUI interface. This is appropriate for a culture in which 99.999% of the users are not programmers in any way, shape, or form, and have no interest in being one.


假设你让一个Unix程序员和一个Windows程序员，分别让他们创建一个相同的终端用户程序。 Unix程序员会创建一个命令行或者文本驱动的程序核心，然后偶尔，作为事后想法会再创建一个用户界面来驱动那个程序核心。通过这种方式，该程序的所有操作都能通过命令行接口分享给其他程序员，他们可以输入命令然后观察输出文本。而Windows程序员则会一开始就从用户界面程序出发， 然后偶尔作为事后想法，添加一个脚本语言作为自动化用户界面操作的接口。 由于99.999%的用户都并非程序员而且根本不会以任何方式，形式想要成为程序员，其实这种文化是非常合适的 。

>There is one significant group of Windows programmers who are primarily coding for other programmers: the Windows team itself, inside Microsoft. The way they tend to do things is to create an API, callable from the C language, which implements the functionality, and then create GUI applications which call that API. Anything you can do from the Windows user interface can also be accomplished using a programming interface callable from any reasonable programming language. For example, Microsoft Internet Explorer itself is nothing but a tiny 89 KB program which wraps together dozens of very powerful components which are freely available to sophisticated Windows programmers and which are mostly designed to be flexible and powerful. Unfortunately, since programmers do not have access to the source code for those components, they can only be used in ways which were precisely foreseen and allowed for by the component developers at Microsoft, which doesn't always work out. And sometimes there are bugs, usually the fault of the person calling the API, which are difficult or impossible to debug without the source code. The Unix cultural value of visible source code makes it an easier environment to develop for. Any Windows developer will tell you about the time they spent four days tracking down a bug because, say, they thought that the memory size returned by LocalSize would be the same as the memory size they originally requested with LocalAlloc, or some similar bug they could have fixed in ten minutes if they could see the source code of the library. Raymond invents an amusing story to illustrate this which will ring true to anyone who has ever used a library in binary form.


当然有一群很重要的Windows程序员主要的任务是为其他程序员编程：就是微软内部的Windows团队本身。他们的行事风格则是创建一个可以用C语言调用的API，实现所需功能，然后创建一个GUI程序调用该接口。 所有你能通过Windows用户界面接口完成的功能都可以通过某些合理的编程语言API接口调用实现。 举个例子来说，微软IE浏览器本身不过就是个89KB的程序，而这个程序则包裹了一堆非常重要的组件。 这些大部分设计的灵活而强大的组件完全开放给从事复杂业务逻辑编程的Windows程序员。不幸的是由于程序员不能直接获得这些组件的源代码，他们使用这些API接口的方式就完全能被微软的这些组件开发者预料到，虽然不总是这样。 有时候有些错误（通常这要怪那些调用这些接口的程序员）因为没有源代码非常难调试。 Unix文化的重视源代码的透明度使得为这个环境开发要更容易。任意一个Windows开发者都能告诉你他为了一个代码错误调试了整整4天。因为，比如说，他们觉得LocalSize调用返回的内存大小总是应该和原来他们通过LocalAlloc请求的内存大小是一样的， 或者是类似这样的代码错误。 这些错误如果他们能看到程序库的源代码也许几分钟就能解决了。 Raymond发明了一个奇妙的故事来让任何使用过二进制形式库代码的程序员产生共鸣。

>So you get these religious arguments. Unix is better because you can debug into libraries. Windows is better because Aunt Marge gets some confirmation that her email was actually sent. Actually, one is notbetter than another, they simply have different values: in Unix making things better for other programmers is a core value and in Windows making things better for Aunt Marge is a core value.


所以你就会听到那些带有“宗教”色彩的争论。Unix更好，因为能够调试进程序库。 Windows更好因为Marge阿姨能够在发出email之后得到确认提示。实际上没有哪个比哪个好， 他们只是有着不同的价值而已： 在Unix里让世界对其他程序员更好是首要价值。 而在Windows让世界对Marge阿姨更好更重要。


>Let's look at another cultural difference. Raymond says, "Classic Unix documentation is written to be telegraphic but complete... The style assumes an active reader, one who is able to deduce obvious unsaid consequences of what is said, and who has the self-confidence to trust those deductions. Read every word carefully, because you will seldom be told anything twice." Oy vey, I thought, he's actually teaching young programmers to write more impossible man pages.


让我们来看另外一个价值差异。 Raymond说，“经典的Unix文档写的就像电报一样但是很完整…这种风格假设任何一个主动的读者都能够推通过已经说明的一切推导出未说明的操作的后果，并且有自信自己能够相信自己的推导。 仔细的阅读那些文字，因为同样的事情几乎不可能说两遍。” 天啊，我觉得他不过是在教另外一个年轻的程序员去写那些不可能让人看懂的用户手册吧。


>For end users, you'll never get away with this. Raymond may call it "oversimplifying condescension," but the Windows culture understands that end users don't like reading and if they concede to read your documentation, they will only read the minimum amount, and so you have to explain things repeatedly... indeed the hallmark of a good Windows help file is that any single topic can be read by itself by an average reader without assuming knowledge of any other help topic.


对于终端用户来说，你根本别想躲过这劫。Raymond也许会把这叫做“天才简化法”，但是Windows用户理解终端用户不喜欢阅读，而且如果他们让步来阅读你的文档，他们只会阅读最少的部分， 因此你要不断重复的解释这些事情… 事实上一个好的Windows帮助文件的标准就在于每一个话题都能够被一般的用户理解而不需要参阅其他的帮助话题的任何知识 或者假设用户已经知道了其他话 题。


>How did we get different core values? This is another reason Raymond's book is so good: he goes deeply into the history and evolution of Unix and brings new programmers up to speed with all the accumulated history of the culture back to 1969. When Unix was created and when it formed its cultural values, there were no end users. Computers were expensive, CPU time was expensive, and learning about computers meant learning how to program. It's no wonder that the culture which emerged valued things which are useful to other programmers. By contrast, Windows was created with one goal only: to sell as many copies as conceivable at a profit. Scrillions of copies. "A computer on every desktop and in every home" was the explicit goal of the team which created Windows, set its agenda and determined its core values. Ease of use for non-programmers was the only way to get on every desk and in every home and thus usability über alles became the cultural norm. Programmers, as an audience, were an extreme afterthought.


为什么会有这样不同的核心价值恩？这就是为什么说Raymond的书写的好的又一个原因了：他巨细无遗的深入了Unix系统的发展历史，帮助新程序员追溯自从1969年以来Unix积累的所有历史和文化价值。 当Unix创建，形成自己的文化价值的时候，根本就没有终端用户。 计算机非常昂贵， CPU时间非常昂贵， 学计算机就意味着学习如何编程。 怪不得这种文化价值就包容了要重视对其他程序员的价值。 相比之下Windows创建的唯一目标就是尽可能的多卖出拷贝来赚取利润。最好卖上万亿拷贝。 “家家户户用电脑”是创建Windows的团队的目标，这个目标确定了议程和核心价值。 让非程序员易于上手是让家家户户都用上电脑的关键，因此可用性“交关重要”的成了文化范式。 程序员作为受众之一则变得极端次要。


>The cultural schism is so sharp that Unix has never really made any inroads on the desktop. Aunt Marge can't really use Unix, and repeated efforts to make a pretty front end for Unix that Aunt Margecan use have failed, entirely because these efforts were done by programmers who were steeped in the Unix culture. For example, Unix has a value of separating policy from mechanism which, historically, came from the designers of X. This directly led to a schism in user interfaces; nobody has ever quite been able to agree on all the details of how the desktop UI should work, and they think this is OK,because their culture values this diversity, but for Aunt Marge it is very much not OK to have to use a different UI to cut and paste in one program than she uses in another. So here we are, 20 years after Unix developers started trying to paint a good user interface on their systems, and we're still at the point where the CEO of the biggest Linux vendor is telling people that home users should just use Windows. I have heard economists claim that Silicon Valley could never be recreated in, say, France, because the French culture puts such a high penalty on failure that entrepreneurs are not willing to risk it. Maybe the same thing is true of Linux: it may never be a desktop operating system because the culture values things which prevent it. OS X is the proof: Apple finally created Unix for Aunt Marge, but only because the engineers and managers at Apple were firmly of the end-user culture (which I've been imperialistically calling "the Windows Culture" even though historically it originated at Apple). They rejected the Unix culture's fundamental norm of programmer-centricity. They even renamed core directories -- heretical! -- to use common English words like "applications" and "library" instead of "bin" and "lib."


这种文化上的分裂是如此的剧烈乃至Unix从没能在桌面市场占得一席之地。 Marge阿姨实在用不了Unix，而且反反复复的尝试给Unix加个漂亮的前端让Marge阿姨能用，还是失败了。 这完全是因为这些努力尝试都是那些沉浸在Unix文化中的程序员迈出的。再举个例子，Unix有种价值叫做“制度策略”分离，这种价值原子X系统的设计者。 这直接就导致了用户界面的分裂； 没有人能同意桌面用户接口应该如何运作的具体细节， 他们觉得这样也是“可以”的，因为他们的价值尊重多样性，但Marge阿姨可不是这么想的，拷贝和粘贴要用两个不一样的UI对她来说是完全不行的。 于是就到了今天， 在Unix程序员尝试在他们的系统上画一个漂亮的界面过去20年之后，世界上最大的Linux提供商的CEO还是在告诉家庭用户用Windows。 我听经济学家说，硅谷绝对不能在法国诞生，因为法国的文化对失败的惩罚是如此之高乃至企业家们都不愿意冒这个险。也许对Linux也是这样的：它永远也成不了桌面操作系统因为它的文化就在阻止它。 OSX就是证明：苹果最终帮Marge阿姨创建了Unix，但这也是因为苹果的工程师和经理热情的拥抱终端用户文化（ 我想非常主观的将其称为“windows”文化，虽然最早源于苹果）。 他们从根本上杜绝了Unix的程序员为中心范式。 他们甚至极端的重命名了核心文件夹 – 使用日常英语例如“程序”和“图书馆”来取代“bin”和“lib”


>Raymond does attempt to compare and contrast Unix to other operating systems, and this is really the weakest part of an otherwise excellent book, because he really doesn't know what he's talking about. Whenever he opens his mouth about Windows he tends to show that his knowledge of Windows programming comes mostly from reading newspapers, not from actual Windows programming. That's OK; he's not a Windows programmer; we'll forgive that. As is typical from someone with a deep knowledge of one culture, he knows what his culture values but doesn't quite notice the distinction between parts of his culture which are universal (killing old ladies, programs which crash: always bad) and parts of the culture which only apply when you're programming for programmers (eating raw fish, command line arguments: depends on audience).


Raymond确实也尝试将Unix和其他操作系统做了对比，这绝对是这本书的败笔，要不是这点这本书绝对棒极了， 因为他真的完全不知道自己在说什么。 当他开口讨论Windows的时候，他似乎是在告诉大家他所有关于Windows编程的知识都是从报纸上看来的，而不是从真正的Windows编程上获得的。 这也还行； 他不是个windows程序员；我们可以原谅这一点。 作为一个对某种文化有着深层次认识的人，他知道他的文化所重视的价值却没有意识到文化中某些部分的特点是共识的（残害老太太，程序会崩溃：当然不好）没有意识到文化的某些部分只有当你在为程序员编程的时候才成立（吃生鱼片，命令行参数：这要看受众）。


>There are too many monocultural programmers who, like the typical American kid who never left St. Paul, Minnesota, can't quite tell the difference between a cultural value and a core human value. I've encountered too many Unix programmers who sneer at Windows programming, thinking that Windows is heathen and stupid. Raymond all too frequently falls into the trap of disparaging the values of other cultures without considering where they came from. It's rather rare to find such bigotry among Windows programmers, who are, on the whole, solution-oriented and non-ideological. At the very least, Windows programmers will concede the faults of their culture and say pragmatically, "Look, if you want to sell a word processor to a lot of people, it has to run on their computers, and if that means we use the Evil Registry instead of elegant ~/.rc files to store our settings, so be it." The very fact that the Unix world is so full of self-righteous cultural superiority, "advocacy," and slashdot-karma-whoring sectarianism while the Windows world is more practical ("yeah, whatever, I just need to make a living here") stems from a culture that feels itself under siege, unable to break out of the server closet and hobbyist market and onto the mainstream desktop. This haughtiness-from-a-position-of-weakness is the biggest flaw of The Art of UNIX Programming, but it's not really a big flaw: on the whole, the book is so full of incredibly interesting insight into so many aspects of programming that I'm willing to hold my nose during the rare smelly ideological rants because there's so much to learn about universal ideals from the rest of the book. Indeed I would recommend this book to developers of any culture in any platform with any goals, because so many of the values which it trumpets are universal. When Raymondpoints out that the CSV format is inferior to the /etc/passwd format, he's trying to score points for Unix against Windows, but, you know what? He's right. /etc/passwd is easier to parse than CSV,  and if you read this book, you'll know why, and you'll be a better programmer.


实在有太多的单一文化的程序员了，就像那种典型的从没离开过明尼苏达州圣保罗的美国小孩一样，他们无法很好的分辨一种文化价值和核心人类价值的区别。 我遇到过不计其数的对Windows编程嗤之以鼻的Unix程序员， 觉得Windows既像邪教又很愚蠢。Raymond之流都太频繁的陷入轻视其他文化的价值而不考虑他们的渊源这种误区。 而这种固执就很难在Windows程序员身上找到，Windows程序员整体来说都是面向解决方案的，非意识形态流。 至少Windows程序员会承认他们的文化的错误，然后务实的说：“看，如果你要把字处理器软件卖给一大堆人，它就必须运行在他们的电脑上， 如果这意味着我们必须要用万恶的注册表而不是优雅的~/.rc文件来存储我们的设定，那也只能这样了”。 事实就是Unix世界里的人都是为自己的文化优越性义愤填膺的人,“倡导者”，./宗教极端分子 而Windows世界里的人则更加务实（“是，管它呢，我只要活着就好”） ，Unix文化的这种邪劲源自于时刻存在危机感的文化， 无法突破服务器机柜市场，无法打开业余爱好者市场，无法跳入主流的桌面市场。这种源自于弱点的傲慢是《UNIX编程艺术》一书最大的缺陷：整体来说，这本书包含了大量对编程方方面面的有趣见解。正因为如此我才愿意在读到恶臭的意识形态咆哮的时候捏住鼻子，因为能够从其余部分学到如此多的通用理念。 事实上我愿意向任何文化在任何平台开发的程序员推荐这本书，因为他鼓吹的大部分理念还是适用的。 当Raymond指出CSV格式比/etc/password格式差的时候，他是想说Unix比Windows更好， 但你猜？ 他是对的。 /etc/passwd 确实比CSV更容易解析， 如果你读了这本书，你就知道为什么 ， 你也会成为更出色的程序员。  
